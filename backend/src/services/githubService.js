const { Octokit } = require('@octokit/rest');
const axios = require('axios');

class GitHubService {
  constructor() {
    this.octokit = null;
  }

  initialize(token) {
    this.octokit = new Octokit({
      auth: token
    });
  }

  async getPullRequest(owner, repo, pullNumber) {
    const { data } = await this.octokit.pulls.get({
      owner,
      repo,
      pull_number: pullNumber
    });
    return data;
  }

  async getPullRequestDiff(owner, repo, pullNumber) {
    const { data } = await this.octokit.pulls.get({
      owner,
      repo,
      pull_number: pullNumber,
      mediaType: {
        format: 'diff'
      }
    });
    return data;
  }

  async getPullRequestFiles(owner, repo, pullNumber) {
    const { data } = await this.octokit.pulls.listFiles({
      owner,
      repo,
      pull_number: pullNumber
    });
    return data;
  }

  async createReviewComment(owner, repo, pullNumber, comment) {
    const { data } = await this.octokit.pulls.createReviewComment({
      owner,
      repo,
      pull_number: pullNumber,
      body: comment.body,
      path: comment.path,
      line: comment.line || comment.position,
      side: comment.side || 'RIGHT'
    });
    return data;
  }

  async createReview(owner, repo, pullNumber, review) {
    const { data } = await this.octokit.pulls.createReview({
      owner,
      repo,
      pull_number: pullNumber,
      body: review.body,
      event: review.event || 'COMMENT',
      comments: review.comments || []
    });
    return data;
  }

  async getFileContent(owner, repo, path, ref) {
    try {
      const { data } = await this.octokit.repos.getContent({
        owner,
        repo,
        path,
        ref
      });
      
      if (data.content) {
        return Buffer.from(data.content, 'base64').toString('utf8');
      }
      return null;
    } catch (error) {
      console.error(`Error fetching file content: ${error.message}`);
      return null;
    }
  }

  async createCheckRun(owner, repo, checkRun) {
    const { data } = await this.octokit.checks.create({
      owner,
      repo,
      name: checkRun.name || 'AI Code Review',
      head_sha: checkRun.headSha,
      status: checkRun.status || 'completed',
      conclusion: checkRun.conclusion || 'success',
      output: {
        title: checkRun.title || 'AI Review Complete',
        summary: checkRun.summary,
        annotations: checkRun.annotations || []
      }
    });
    return data;
  }

  formatReviewComment(issue, file) {
    let comment = `**${issue.severity.toUpperCase()}**: ${issue.message}\n\n`;
    
    if (issue.suggestion) {
      comment += `üí° **Suggestion**: ${issue.suggestion}\n\n`;
    }
    
    if (issue.rule) {
      comment += `üìè **Rule**: \`${issue.rule}\`\n`;
    }
    
    if (issue.type) {
      comment += `üè∑Ô∏è **Type**: ${issue.type}\n`;
    }
    
    comment += `\n---\n*Generated by AI Code Companion*`;
    
    return {
      path: file.filename,
      line: issue.line || 1,
      body: comment
    };
  }

  async postStatusCheck(owner, repo, sha, status) {
    const { data } = await this.octokit.repos.createCommitStatus({
      owner,
      repo,
      sha,
      state: status.state || 'success',
      target_url: status.targetUrl,
      description: status.description || 'AI Code Review',
      context: 'ai-code-companion'
    });
    return data;
  }
}

module.exports = new GitHubService();